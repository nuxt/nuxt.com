---
title: Refreshed Nuxt ESLint Integrations
description: We have refreshed our ESLint integrations to support ESLint v9 with the flat config, as well as a new module many more capabilities.
image: /assets/blog/nuxt-eslint-refreshed.png
authors:
  - name: Anthony Fu
    avatarUrl: https://github.com/antfu.png
    link: https://github.com/antfu
    twitter: antfu7
date: 2024-04-10T00:00:00.000Z
category: Article
---

[ESLint](https://eslint.org/) has become en essential tool for today's web development. It helps you to catch errors and enforce consistent coding style in your project. In Nuxt, we try to provide the out-of-the-box experience for ESLint, making it easy to use and configure and following the best practices we recommend. 

Over time, both Nuxt and ESLint has evolved a lot since then. And historically, we ended up with [a few different packages and integrations for ESLint in Nuxt](https://eslint.nuxt.com/guide/faq#package-disambiguation), and wasn't always very clear which one to use for what purpose. We have heard quite a few feedbacks from you and the community.

To improve the situation and also make it future-proof for the community, recently, we have refreshed our ESLint integrations to support [ESLint v9](https://eslint.org/blog/2024/04/eslint-v9.0.0-released/) with the [flat config](https://eslint.org/docs/latest/use/configure/configuration-files) and opens up many more capabilities for customizing your ESLint setup, providing a more straightforward and unified experience.

## Nuxt ESLint Monorepo

To avoid the confusion and provide a more unified experience, we move ESLint related packages which were previously scattered across different repositories into a single monorepo: [`nuxt/eslint`](https://nuxt.com/modules/eslint), with a dedicated new documentation site: [eslint.nuxt.com](https://eslint.nuxt.com/).

To help understanding the differences between each package and what to use, we also have a [FAQ](https://eslint.nuxt.com/guide/faq) page comparing them and explaining the their scopes.

This monorepo now includes:

- `@nuxt/eslint` - The new, all-in-one ESLint module for Nuxt 3, supporting project-aware ESLint flat config and more.
- `@nuxt/eslint-config` - The unopinionated but customizable shared ESLint config for Nuxt 3. Supports both [the flat config format](https://eslint.org/docs/latest/use/configure/configuration-files) and [the legacy format](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated).
- `@nuxt/eslint-plugin` - The ESLint plugin for Nuxt 3, providing Nuxt-specific rules and configurations.
- And a few legacy packages for Nuxt 2 in maintenance mode.

## ESLint Flat Config

Before we start to talk about the new Nuxt integrations, let me first introduce you a bit about the concept of [ESLint flat config](https://eslint.org/docs/latest/use/configure/configuration-files).

Flat config is the new default configuration format introduced that first landed as experimental in ESLint v8.21.0, and became stable and the default in [ESLint v9](https://eslint.org/blog/2024/04/eslint-v9.0.0-released/).

A quick reference to differentiate:

- **Flat config**: `eslint.config.js` `eslint.config.mjs` etc.
- **Legacy config**: `.eslintrc` `.eslintrc.json` `.eslintrc.js` etc.

### Why Flat Config?

[This blog post from ESLint](https://eslint.org/blog/2022/08/new-config-system-part-1/) explains the motivation behind the flat config system in detail. In short, the legacy eslintrc format was designed at the early time of JavaScript, where ES modules and modern JavaScript features were not yet standardized. There were many implicit conventions evolved, and the `extends` feature makes the final config result hard to understand and predict. Which also make shared configs hard to maintain and debug.

```jsonc [.eslintrc]
{
  "extends": [
    // Solve from `import("@nuxtjs/eslint-config").then(mod => mod.default)`
    "@nuxtjs",
    // Solve from `import("eslint-config-vue").then(mod => mod.default.configs["vue3-recommended"])`
    "plugin:vue/vue3-recommended",
  ],
  "rules": {
    // ...
  }
}
```

The new flat config moves the plugins and configs resolution from ESLint's internal convention to the native ES module resolution, which makes it more explicit and transparent, that you can even import it from other modules. Since the flat config is just a JavaScript module, it also opens the door for much more customization and possibilities.

## Nuxt Presets for Flat Config

In the latest [`@nuxt/eslint-config` package](https://eslint.nuxt.com/packages/config#flat-config-format), we leverage the flexibility we have to provide a factory function that allows you customize the config presets easily in a more high-level way. Here is an example of how you can use it:

```ts [eslint.config.js]
import nuxt from '@nuxt/eslint-config/flat'

export default nuxt()
```

`@nuxt/eslint-config` starts with an unopinionated base config, which means we only include rules for best practices of TypeScript, Vue and Nuxt, and leave the rest like code style, formatting, etc for you to decide. You can also run [Prettier](https://prettier.io/) alongside for formatting with the defaults.

The config also allows to opt-in more opinionated features as need. For example, if you want ESLint to take care of the formatting as well, you can turn it on by passing `features.stylistic` to the factory function (powered by [ESLint Stylistic](https://eslint.style/)):

```ts [eslint.config.js]
import nuxt from '@nuxt/eslint-config/flat'

export default nuxt({
  features: {
    stylistic: true
  }
})
```

Or tweak the your preferences with an options object ([learn more with the options here](https://eslint.style/guide/config-presets#configuration-factory)):

```ts [eslint.config.js]
import nuxt from '@nuxt/eslint-config/flat'

export default nuxt({
  features: {
    stylistic: {
      semi: false,
      indent: 2, // 4 or 'tab'
      quotes: 'single',
      // ... and more
    }
  }
})
```

And if you are [authoring a Nuxt Module](https://nuxt.com/docs/guide/going-further/modules), you can turn on `features.tooling` to enable the rules for the Nuxt module development:

```ts [eslint.config.js]
import nuxt from '@nuxt/eslint-config/flat'

export default nuxt({
  features: {
    tooling: true
  }
})
```

...and so on. The factory function in flat config allows the presets to cover the complexity for underlying ESLint configuration, and provide high-level and user-friendly abstractions for end users to customize. Without requiring users to worry about the internal details.

While this approach offers you a Prettier-like experience with minimal configurations, because it's powered by ESLint, you still get the full flexibility to customize and overrides fine-grained rules and plugins as needed. 

We also made a [`FlatConfigComposer`](https://github.com/antfu/eslint-flat-config-utils#composer) utility from [`eslint-flat-config-utils`](https://github.com/antfu/eslint-flat-config-utils) to make it even easier to override and extends the flat config. The factory function in `@nuxt/eslint-config/flat` returns a `FlatConfigComposer` instance already:

```ts [eslint.config.js]
import nuxt from '@nuxt/eslint-config/flat'

export default nuxt({
  // ...options for Nuxt integration
})
  .append(
    // ...append other flat config items
  )
  .prepend(
    // ...prepend other flat config items before the base config
  )
  // override a specific config item based on their name
  .override(
    'nuxt/typescript', // specify the name of the target config, or index
    {
      rules: {
        // ...override the rules
        '@typescript-eslint/no-unsafe-assignment': 'off'
      }
    }
  )
  // an so on, operations are chainable
```

With this approach, we get the best of both worlds: the simplicity and high-level abstraction for easy to use, and the power for customization and fine-tuning.

## Nuxt ESLint Module

Taking this even further, we made the new, all-in-one [`@nuxt/eslint` module](https://eslint.nuxt.com/packages/module) for Nuxt 3. It leverages Nuxt's context to generate project-aware and type-safe ESLint configurations for your project.

### Project-aware Rules

We know that Vue's Style Guide suggests to use [multi-word names for components](https://vuejs.org/style-guide/rules-essential.html#use-multi-word-component-names) to avoid conflicts with existing and future HTML elements. Thus, in [`eslint-plugin-vue`](https://github.com/vuejs/eslint-plugin-vue), we have the rule [`vue/multi-word-component-names`](https://eslint.vuejs.org/rules/multi-word-component-names.html) enabled by default. It's a good practice to follow, but we know that in a Nuxt project, not all `.vue` files are registered as components. Files like `app.vue`, `pages/index.vue`, `layouts/default.vue`, etc. are not available as components in other Vue files, and the rule will irrelevant for them.

Usually, we could disable the rule for those files like:

```js [eslint.config.js]
export default [
  {
    files: ['*.vue'],
    rules: {
      'vue/multi-word-component-names': 'error'
    }
  },
  {
    files: ['app.vue', 'error.vue', 'pages/**/*.vue', 'layouts/**/*.vue'],
    rules: {
      // disable the rule for these files
      'vue/multi-word-component-names': 'off'
    }
  }
]
```

It should works for majority of the cases, however, we know that in Nuxt you can [customize the path for each directory](https://nuxt.com/docs/api/nuxt-config#dir), and [layers](https://nuxt.com/docs/getting-started/layers) allows you to have multiple sources for each directory. This means the linter rules will be less accurate and potentially cause users extra effort to keep them aligned **manually**.

Similarly we want to have [`vue/no-multiple-template-root`](https://eslint.vuejs.org/rules/no-multiple-template-root.html) enabled only for `pages` and `layouts` etc. As the cases grows, it becomes unrealistic to ask users to maintain the rules manually.

That's where the magic of `@nuxt/eslint` comes in! It leverage the Nuxt's context to the generates the configurations and rules that specific to your project structure. Very similiar to the [`.nuxt/tsconfig.json`](http://nuxt.com/docs/guide/concepts/typescript#auto-generated-types) Nuxt provides, you now also have the project-aware `.nuxt/eslint.config.mjs` to extend from.

To use it, you can simply add the module to your Nuxt project:

```bash
npx nuxi module add eslint
```

### Config Inspector DevTools Integrations

During the migrations and research for the new flat config, Anthony came up with the idea to make an interactive UI inspector for the flat config and make the configurations more transparent and easier to understand. We have integrated it into [Nuxt DevTools](https://github.com/nuxt/devtools) when you have the `@nuxt/eslint` module installed so you easily access it whenever you need it.

![Screenshot of ESLint Config Inspector running as a tab in Nuxt DevTools](/assets/blog/nuxt-eslint-inspector.png)

The inspector allows you to see the final resolved configurations, rules and plugins that has enabled, and do quick matches to see how rules and configurations has applied to specific files. It's great for debugging and learning how ESLint works in your project.

We are very happy to know that the ESLint team also find it useful and are interested to have it also for the broader ESLint community. We later join the effort and made it [the official ESLint Config Inspector](https://github.com/eslint/config-inspector) (it's built with Nuxt by the way), you can read [this announcement post](https://eslint.org/blog/2024/04/eslint-config-inspector/) for more details.

### Type Generation for Rules

One of main pain points of configuring ESLint was the leak of type informations for the rules and configurations. It's hard to know what options are available for a specific rule, and would requires you to jump around the documentation to for every rule to figure that out.

Thanks again to that the new flat config are dynamic, opening up so many possibilities. The thing we figured out a new tool [`eslint-typegen`](https://github.com/antfu/eslint-typegen), that we could generate the corresponding types from rules configuration schema for each rule **based on the actual plugins you are using**. This means it's an universal solution that works for any ESLint plugins and the types are always accurate and up-to-date.

In the `@nuxt/eslint` module, this feature is integrated, so that you will get this awesome experience out-of-the-box:

![Screenshot of VS Code that showcases the type check and autocomplete with ESLint rules config](/assets/blog/nuxt-eslint-typegen.png)

### Dev Server Checker

With the new module, we also take the chance to merge the [`@nuxtjs/eslint-module`](https://github.com/nuxt-modules/eslint), the dev server checker for ESLint, into the new `@nuxt/eslint` module as an opt-in feature. You might not need this feature for most of the time, as your editor integration should already provide ESLint diagnostics right in your editor. But for teams that works with different editors and want to make sure ESLint is always running, being able to run ESLint within the dev server might be useful in some cases.

To enable it, you can set the `checker` option to `true` in the module options:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  modules: [
    '@nuxt/eslint'
  ],
  eslint: {
    checker: true // <---
  }
})
```

Every time when you got some ESLint errors, you will see a warning in the console and the browser. To learn more about this feature, you can check the [documentation](https://eslint.nuxt.com/packages/module#dev-server-checker).

### Module Hooks

Since now we are in the Nuxt module with the codegen capabilities and the project-aware configurations, we can actually do a lot more interesting things with this. One is that we can allow modules to contribute to the ESLint configurations as well. Imagine that in the future, when you install a Nuxt module like `@nuxtjs/i18n` it can automatically enable specific ESLint rules for i18n related files, or when you install something like `@pinia/nuxt` it can install the Pinia ESLint plugin to enforce the best practices for Pinia, etc.

As an experiments, we made a module [`nuxt-eslint-auto-explicit-import`](https://github.com/antfu/nuxt-eslint-auto-explicit-import) that can do auto inserts for the auto-imports registered in your Nuxt project with a preconfigured ESLint preset. So that you can get the same nice developer experience with auto-imports on using APIs, but still have the auto-inserted explicit imports in your codebase.

This is still in the early stage and we are still exploring the possibilities and best practices for this. But we are very excited about the potential and the possibilities it opens up. We will collaborate with the community to see how we can make the most out of it. If you have any ideas or feedback, please do not hesitate to share with us!

## Ecosystem

At Nuxt, we care a lot about the ecosystem and the community as always. During our explorations to adopt to the new flat config and improving the developer experience, we made quite a few tools to reach that goal. All of them are general purposed and can be used outside of Nuxt:

- [`@eslint/config-inspector`](https://github.com/eslint/config-inspector) - The official ESLint Config Inspector, provide interactive UI for your configs.
- [`eslint-typegen`](https://github.com/antfu/eslint-typegen) - Generate TypeScript types for ESLint rules based on the actual plugins you are using.
- [`eslint-flat-config-utils`](https://github.com/antfu/eslint-flat-config-utils) - Utilities for managing and composing ESLint flat configs.

We are looking forward to see how these tools can help the broader community and how we can collaborate with the community to make them better and expand the possibilities.

## The Future

The flat config format is still fairly new, and ESLint v9 which is the first version that have flat config generally enabled is just released a couple weeks ago. Plugins and the community are still catching up to the new format gradually. It's still in the phase of exploring and experimenting. We are very excited to see how the ESLint ecosystem will evolve with the new capabilities and possibilities, and how we can leverage them to make Nuxt's developer experience even better.
