---
title: Nuxt Icon v1
description: Introducing the new Nuxt Icon v1 - a modern, versatile, and customizable icon for your Nuxt projects.
image: /assets/blog/todo.png
authors:
  - name: Anthony Fu
    avatarUrl: https://github.com/antfu.png
    link: https://github.com/antfu
    twitter: antfu7
date: 2024-11-25T00:00:00.000Z
category: Release
---

Hello everyone, good to be here again at Nuxt Nation!

For today's topic, I'd like to talk about Nuxt Icon. I'll walk you through various of different solutions on rendering icons on web pages, with their pros and cons. And how we managed to find a balance trade-offs in the Nuxt Icon module and deliver to you.


So, let's first talk about icons in general.

So, what are icons?  To me, they are tiny image assets that represent graphics, making functionality easier to identify and understand, while also making the UI more interesting and engaging.

However, icons are not just images; they come with unique requirements based on their usage.

 I'd say, while the concept of icons is simple, engineering them correctly is quite complicated.

Here, you can see many icons from different collections, each with its own properties and requirements. Let's break them down from an engineering perspective.

Rendering good icons comes with a few challenges beyond just displaying plain images.

 First, we need icons to be colorable. Most icons are monochrome, but they often need to adapt their colors based on the context, such as switching between light and dark modes. It's ideal if we can change their colors on the fly, so we don't have to design multiple versions of the same icon.

 Similarly, icons should be scalable. They need to fit different screen sizes or UI elements without losing quality. It would be great if we could resize them easily.

 Besides rendering, we also need to think about how we deliver icons. Icon sets usually include a large number of icons to cover various needs, but we rarely use all of them in a single page or app.

 To improve performance and save bandwidth, we need to consider how we bundle them. How flexible and granular can we be in splitting the icon sets into chunks? Should we create chunks based on how commonly icons are used, or can we be granular enough to only ship the icons we actually use?

 After bundling, we need to decide how to load the icons. Should we include them in the same bundle as the client app, or as separate lazy-loaded chunks?

 Finally, we need the capability to load icons dynamically, especially for user-provided data that we don't know about at build time.

These are some of the key challenges we face with icons. Depending on your use case, you might only need to address some of them. But when creating tools, we aim to find a good balance to support as many scenarios as possible. So, let's explore the solutions available for icons and compare their pros and cons.


Let's start with the most straightforward solution: using the image tag. This was pretty much the only option in the early days of the web.

You'd host your image assets somewhere,  and then use an image tag to link to that image, specifying its width and height.

 Here are some examples from back in the day. Personally, I'm a big fan of pixel art and love this retro style.

 There are definitely some advantages to this approach. It's very simple, requires no setup or runtime dependencies, and works natively in browsers.

 However, there are also quite a few drawbacks. Images can become pixelated, meaning we don't have any color control and they don't scale well. Each icon being a separate image file results in many network requests, which could be slow, especially back in the days of HTTP 1.1. Before the image is downloaded, you might see a flash of invisible icons, which can hurt the user experience. Lastly, it's quite verbose to write, as you need to specify the full path of the image and manage the relative paths.

Given these downsides, it's no surprise that this approach is rarely used on websites today.


Then Web Fonts becomes the second solution. As fonts are by natural vectorized and colorable, it's soon be chosen to serve icons.

 Usually the iconset providers will compile their icons into a special font file, that assign a special unicode character to represnet each icon. Accompany with a CSS file to set the unicode value for each icon classes.

 The usage would be looked like this.

 Underneath, the CSS file would looks a bit like this. A common style selector, and then selectors for each icons to their assigned unicode value.

 The adventages of this approach is that it's easy to use, colorable, scalable, and only requires a single request to load all icons.

 However, the downside is that it requires a large font file to load all icons upfront, which can be slow. It's also hard to customize the icon set, and you might see a flash of invisible icons before the font is loaded because there are no fallback fonts.

And then, with frontend frameworks comes to the game, reuse HTML elements because a lot easier. People came up with the idea of directly inline the SVG tags as component.

For iconsets to support this approach, they often comes with packages to provide their wrappers for each framework.

 For example, MDI icons use a shared component and provide icon data as a pros, while  Tablar icons provide component for each icon.

 Because they are SVGs, they are colorable, scalable, and have all the features of SVGs. Usually people bundles icon into the app, so there are no additional networks requests, and it's even SSR friendly and visible at the first render.

 However, the downsides are that it creates a lot of SVG DOM elements, which can hurt the performance when you have a lot of icons. It also increases the bundle size, and requires specific integration support for each icon set and framework combinations. This implies a level of vendor lock-in, making it hard to switch to another icon set or framework.

And to be fair, these trade-offs are already quite a good deal, many projects are using this approach today as you don't really switch icon sets or frameworks very often.





Talking about vender lock-in, I'd like to bring up this open source project called Iconify.

 Iconify is a unified icon framework that provides a single solution for all popular icon sets.

 It offers a unified collection of data for consuming,  and supports over 100 open source icon sets with more than 200,000 icons.

 They even provides an server API for your to fetch icons dynamically. Any icon is just one request away.

The solutions we are going to talk later on are all built on top of it, meaning that you don't need to worries about the iconset support anymore and can switch to any iconset or even mix them with zero migration needed.

 Iconify really did the heavy lifting works underneath to collect and normalize all those icons, which I would invite you to sponsor Iconify on GitHub or Open Collective to support their work if you are benefit from its ecosystem.

Here I also made an icon explorer for Iconify called Ic√¥nes. You can browser all the icons from Iconify collection, copy or download them as ease. The URL is icon-e-s.js.org

So back to the solutions we were talking about, Iconify also comes with it's own runtime solution. That you can simpliy  import the library and  use any icons as an web components.

 Under the hood, the component will send requests to the Iconify API, and the api will serve the needed icons from the massive icons collection.

 This is a great fit for rendering icons from user provided content or some other dynamic content that you don't know at build time. And it's super easy to setup, that you can even use it as a CDN without any build tools.

 The downsides are that it would add a runtime dependencies, that your icons will only renders after JavaScript is loaded and the icon get fetched. This also would not work for SSR and cache layers like PWA.


With the unified interface from Iconify, combining with Vite's on-demand approach, we made unplugin-icons that supports you to  import any icons on-demand as components.

Because it's an unplugin, it supports all popular build tools including Vite, webpack and rspack etc. We provide compiler for all popular frameworks like Vue, React, Svelte, Solid etc. And with Iconify, we make it possible to have one single solution for any framework to use any icons.  Estimate the vendor-lockin on your choices of icons.

So, because this is still fundentamally the same technique as the previous component icons solution.  We share the same pros and cons. The difference is that with build tools integrated, we are able to serve the full collections of Iconify while only ship the icons you actually used.  However, at runtime we still have the concern of DOM elements and so on.


As a side-effect of creating UnoCSS, I discovered that it's possible to embed icons entirely in CSS, leading to the solution of Pure CSS Icons.

 This method inlines SVG icons as data URLs and provides a single class to display the icons.  With some tweaks, the icons become colorable, scalable, and even capable of displaying SVG animations.

 Browsers can cache the CSS rules, and each icon only requires one DOM element to render. This approach ships the icons in a single CSS file with no additional requests. Since it's pure CSS, the icons display along with the rest of your UI, require zero runtime, and work naturally with SSR - your server doesn't need any extra work on the server side.

 The only downsides are the lack of full customization for elements inside the SVG and the need to bundle icons at build-time, which isn't dynamic.

I highly recommend this approach for most cases where you don't need to dynamically render user-provided icons. In my opinion, it's the most well-rounded solution so far. If you use UnoCSS, install the icon presets, and you will be able use this feature just like any other utility class.

Finally, let's talk about Nuxt. Our goal with Nuxt is to provide seamless solutions that cover as many use cases as possible.

 Let's quickly go over the integration challenges we faced to make Nuxt Icon comprehensive.

 First, we need to support both SSR and CSR, as they are core features of Nuxt. We want to ensure that icons render without any flashes for the best user experience.

 We also want to support dynamic icons, such as those from Nuxt Content, allowing you to use icons from your content data.

 Performance is crucial, so we need to ensure that our solution doesn't compromise on speed.

 Lastly, we want to support custom icons. In addition to the thousands of icons from Iconify, users should be able to load their custom icons using the same syntax.

With these requirements in mind,  let's compare the solutions we discussed earlier.

 For dynamic icons, the Iconify Runtime seems to be the only option. However, it doesn't work perfectly with SSR and doesn't support custom icons, as the requests go to Iconify's servers, which aren't aware of our local setup.

 On the other hand, CSS Icons are performant and work well with SSR, but they don't support dynamic icons.

[pause a bit]

So, which should we choose? That's tough as we seems to either option we are trading off something we need.

Ummm, so,  why don't we choose both?

First, to ease out the trade-off of rendering approach, in Nuxt Icon, we provided an <Icon> component that supports both CSS and SVG Mode - both are SSR friendly. Deps on how much customize you need, you can switch between to mode per icon.

 For CSS Mode, the icon will ben included in the CSS from SSR.

 While for the SVG mode, the icon will be flatten as inlined HTML during SSR.

 Both approach allows icon to be rendered at the initial screen without runtime cost.

Let's talk about dynamic icons and how we can optimize their loading.

 For dynamic icons, we can use Iconify's API,  which serves any icon on demand via network requests. The downside is that these API servers might be far from your users, causing delays.

 To improve this, if we know certain icons will always be used, we can bundle them directly into the client. This way, they render instantly without additional requests.  However, we can only do this for statically known icons. Bundling all possible icons would make the bundle size too large.

Since Nuxt is a full-stack framework,  we can find a middle ground by introducing a server bundle. On the server side, bundle size is less of an issue,  so we can include more icon sets. During SSR, these icons can be fetched quickly and sent to the client on demand. With this setup, we can use the Iconify API as a final fallback, ensuring high performance for commonly used icons while still being able to serve any icon from Iconify.


Let's walk through the data flow to make it clearer.

 Wen can provide the icon id to the Icon component to use it.  The component first checks if the icon is already server-rendered. If it is, we stop there since the icon is already present.

 If not, then we will look up the client bundle for it. Most static-known icons will be there, so we can render them directly.

 For dynamic icons that aren't in the client bundle, the component will request them from our server endpoint. This endpoint is usually deployed along with your app and close to end users.  The server looks for the requested icons in the server bundle and serves them back to client.  We have caching on both the browser and API endpoints, so once an icon is requested, subsequent requests are much faster.

 If the server can't find the icon in its bundle, it requests the icon from Iconify and forwards it to the client. In this case, caching is also applied to speed up future requests.

With all these steps, we can load icons efficiently while supporting dynamic icons.

So, that's the approach we've explored in Nuxt Icon v1.0. We believe we've found a balance that minimizes trade-offs, offering both a great user experience and flexibility.

Give it a try and let us know what you think! We're excited to hear your feedback!

