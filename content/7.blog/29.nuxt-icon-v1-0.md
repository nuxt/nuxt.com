---
title: Introducing Nuxt Icon v1
description: Introducing the new Nuxt Icon v1 - a modern, versatile, and customizable icon for your Nuxt projects.
image: /assets/blog/todo.png
authors:
  - name: Anthony Fu
    avatarUrl: https://github.com/antfu.png
    link: https://github.com/antfu
    twitter: antfu7
date: 2024-11-25T00:00:00.000Z
category: Release
---

Icons are integral to modern web interfaces. They simplify navigation, clarify functionality, and make user interfaces visually engaging. But behind the scenes, implementing icons efficiently is a multifaceted challenge. Issues like scalability, dynamic loading, and server-side rendering (SSR) compatibility can quickly complicate even the simplest designs.

To tackle these challenges, we developed **Nuxt Icon v1** — a versatile, modern solution tailored for Nuxt projects. By building on established icon rendering techniques and introducing novel approaches, Nuxt Icon bridges the gap between performance, usability, and flexibility.

In this post, we’ll delve into the challenges of icon rendering, the evolution of icon solutions, and how Nuxt Icon combines the best aspects of these methods to offer a seamless experience for developers.

---

## Why Are Icons Challenging?

At a glance, icons seem simple - they are essentially just tiny image elements that enhance a user interface, providing visual cues and enhancing usability. 

![Icons Showcases](/assets/blog/nuxt-icon/icons-showcase.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}

However, from an engineering perspective, they pose several challenges - the icons need be:

- **Colorable**: Icons should adapt to different color schemes and themes on the fly.
- **Scalable**: Icons must render crisply at various sizes and resolutions.
- **Large Amount**: Iconsets can contain hundreds or thousands of icons, requiring quite some effort to manage.
- **Bundling**: Icons should be bundled efficiently to minimize network requests.
- **Loading**: How the icons are loaded can affect the performance of the application and user experience.
- **Dynamic**: Icons should support dynamic loading for user-generated content or runtime-defined icons.

![Engineering Challenges with Icons](/assets/blog/nuxt-icon/challenges.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}

Meeting all these needs requires a carefully engineered solution that balances trade-offs. 

Let me first walk you through how icon rendering has evolved over time.

---

## A Journey Through Icon Solutions

Over the years, developers have experimented with various techniques to render icons efficiently. Let’s explore the evolution of these solutions and the challenges they faced.

### 1. `<img>` Tags: The Early Days

Initially, icons were static image files loaded using `<img>` tags. While this approach was simple and browser-native, it had several drawbacks:

- Icons became pixelated when scaled.
- Changing icon colors required multiple image versions.
- Each icon required a separate network request, slowing down page loads.

This approach is rarely used today, given its limitations.

![Solution 1](/assets/blog/nuxt-icon/solution-1.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}

---

### 2. Web Fonts: Icon Fonts

Icon fonts emerged as a scalable solution, mapping icons to font glyphs. Using CSS, developers could style and resize these icons like text. This method introduced benefits like single-request loading and easy color styling. However:
- Font files included all icons, leading to bloated downloads.
- Customizing individual icons was nearly impossible.
- Before the font loaded, users experienced a flash of invisible icons (FOIC).

![Solution 2](/assets/blog/nuxt-icon/solution-2.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}

---

### 3. Inline SVGs: Component-Based Icons

With frontend frameworks, SVGs became the go-to solution for rendering icons. Developers could inline SVGs, making them colorable, scalable, and framework-agnostic. This approach also supported SSR, ensuring icons rendered instantly.

However:
- Each icon added to the DOM as a separate SVG increased complexity and size.
- The approach required framework-specific integrations, creating potential vendor lock-in.

![Solution 3](/assets/blog/nuxt-icon/solution-3.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}

---

### 4. Iconify Runtime: Dynamic API Access

[Iconify](https://iconify.design/) revolutionized icon usage by aggregating over 200,000 icons across 100+ collections. Its runtime solution dynamically fetched icons via an API, enabling dynamic access to any icon without pre-bundling.

![Solution 4](/assets/blog/nuxt-icon/solution-4.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}

This solution was perfect for user-generated or runtime-defined icons. However:

- It introduced runtime dependencies.
- API calls could delay rendering, especially without a robust caching strategy.
- It wasn’t SSR-friendly, limiting its use in some projects.

---

### 5. On-Demand Component Icons

With the unified interface from Iconify and Vite's on-demand approach, we developed [`unplugin-icons`](https://github.com/unplugin/unplugin-icons). This tool allows you to import any icons as components on-demand.

As an [`unplugin`](https://github.com/unjs/unplugin), it supports all popular build tools, including Vite, webpack, and rspack. We provide compilers for popular frameworks like Vue, React, Svelte, and Solid. With Iconify, you can use any icon across any framework, minimizing vendor lock-in.

![Solution 5](/assets/blog/nuxt-icon/solution-5.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}

While this technique shares the same pros and cons as previous component icon solutions, the integration with build tools allows us to serve the full Iconify collection while only shipping the icons you actually use. However, runtime concerns like DOM element management still persist.

---

### 6. Pure CSS Icons

As a side-effect of working on [UnoCSS](https://unocss.dev/), we discovered the potential of embedding icons entirely in CSS, leading to the innovative solution of [Pure CSS Icons](https://antfu.me/posts/icons-in-pure-css).

This method involves inlining SVG icons as data URLs and providing a single class to display the icons. With some tweaks, these icons become colorable, scalable, and even capable of displaying SVG animations.

Browsers can cache the CSS rules, and each icon requires only **one DOM element** to render. This approach ships the icons in a single CSS file with no additional requests. Since it's pure CSS, the icons display along with the rest of your UI, require zero runtime, and work naturally with SSR—your server doesn't need any extra work on the server side.

The only downsides are the lack of full customization for elements inside the SVG and the need to bundle icons at build-time, which isn't dynamic.

![Solution 6](/assets/blog/nuxt-icon/solution-6.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}

---

## The Challenges to Integrate in Nuxt

While I would say that the [Pure CSS Icons](#_6-pure-css-icons) and [On-demand Component Icons](#_5-on-demand-component-icons) would be pretty sufficient for most of the static usages, Nuxt as a full featured framework, has a bit more requirements to integrate icons efficiently:

- **SSR/CSR**: Nuxt works in both server-side rendering (SSR) and client-side rendering (CSR) modes. We care a lot about the end user experience, and we want to ensure that icons are rendered instantly without flickers.
- **Dynamic Icons**: In integrations like [Nuxt Content](https://content.nuxtjs.org/), the content can be provided at runtime or from external sources, which we are not aware at build time. We want to ensure we have the capability to integrate with those cases well.
- **Performance**: We want to ensure that the icons are bundled efficiently, and the loading of icons is optimized for the best performance.
- **Custom Icons**: While Iconify provides a wide range of icons for selection, we also aware it's pretty common for projects to have their own icon sets, or wanted to use paid icons that are not avaible in Iconify. Supporting custom icons is crucial for our users.

![Nuxt Integration Challenges and Solutions](/assets/blog/nuxt-icon/nuxt-icon-challenges.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}

Looking at those challenges, 

---

## Introducing Nuxt Icon v1: The Balance of Both Worlds

Nuxt Icon was built to address these limitations and unify the strengths of previous solutions. It integrates seamlessly into Nuxt projects and provides robust support for both static and dynamic icons.

---

### Dual Rendering Modes

// TODO:

![Dual rendering mode](/assets/blog/nuxt-icon/dual-rendering-modes.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}


---

### Bundles

// TODO:

![Bundles Concept in Nuxt Icons](/assets/blog/nuxt-icon/bundles.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}


---

### Data Flow

Here is a data flow diagram illustrating how Nuxt Icon requests icon data:

1. You use the `<Icon>` component and provide the icon `name`.
2. Nuxt Icon will first check if the icon is available in the `Client Bundle`, or the SSR payload (icons that known at SSR will be presented in the payload). If so, the icon will be renderred instantly.
3. If the icon is not available at the client side, Nuxt Icon will fetch the icon data from the server API shipped along with your Nuxt app. Inside the server endpoint, it will query from the `Server Bundle` to see if the icon is available.
4. Between that, there are multiple cache systems involved. Server endpoint cache, HTTP cache, and client-side cache to ensure the icon is fetched efficiently and quickly. Due to that icon data are not changed frequently, we use hard cache strategies to ensure the best performance.
5. When the icon is unknown to both the client and server (dynamic icons), the server endpoint will fallback to the Iconify API to fetch the icon data. Since the server endpoint is cached, the Iconify API will be called only once for each unique icon regardless how many clients are requesting it, to save the resources on both sides.

![Nuxt Icon Requesting Data flow](/assets/blog/nuxt-icon/dataflow.png){.border.border-gray-200.dark:border-gray-700.rounded-lg}

This layered approach ensures efficient icon delivery, balancing speed and flexibility, while being as dynamic as possible. And balance out the trade-offs between each solution.

---

## Try Nuxt Icon Today


Nuxt Icon v1 represents the culmination of years of innovation in icon rendering. Whether you’re building a dynamic app, a static website, or anything in between, Nuxt Icon adapts to your needs.

It’s easy to add Nuxt Icon to your project by running the following command:

```bash
npx nuxi module add icon
```

Then, import the `<Icon>` component in your Vue components, providing icon `name` following [Iconify's conventions](https://iconify.design/getting-started/):

```vue
<template>
  <Icon name="ph:arrow-down-duotone" />
</template>
```

Explore more with the [documentation](https://github.com/nuxt/icon), experiment with its features, and let us know your thoughts. We’re excited to see how Nuxt Icon transforms your projects!

**Happy Nuxting ✨**
